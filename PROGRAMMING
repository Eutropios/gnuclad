Small documentation if you wish to hack gnuclad.

Table of Contents:

1. Contributing
2. Adding a parser/generator
3. Classes
4. How to write a parser
5. How to write a generator
6. Utility functions


////////////////////////////////////////////////////////////////////////////////

1. CONTRIBUTING

Current project page:
https://launchpad.net/gnuclad

Patches always welcome. New parsers/generators even more so!


////////////////////////////////////////////////////////////////////////////////

2. ADDING A PARSER/GENERATOR

Parsers read data from various sources into the Cladogram object,
generators write data from the Cladogram object to a specified output format.

This is a short overview over the steps necessary to include a parser/generator.
For detailed information, see the "How to write a ..." chapters below.


Adding a parser
  parserXXX.h:
    #include "gnuclad.h"
    derive class from Parser:
      class ParserXXX: public Parser
    add public method:
      void parseData(Cladogram * clado, std::ifstream * fp);

  parserXXX.cpp:
    #include "parserXXX.h"
    implement parseData();

  gnuclad.cpp:
    #include "parserXXX.h"
    update inFormats
    add choser:
      else if(inputExt == "XXX") parser = new ParserXXX;


Adding a generator
  generatorXXX.h:
    #include "gnuclad.h"
    derive class from generator:
      class GeneratorXXX: public Generator
    add public method:
      void writeData(Cladogram * clad, std::ofstream * fp);

  generatorXXX.cpp:
    #include "generatorXXX.h"
    implement writeData();

  gnuclad.cpp
    #include "generatorXXX.h"
    update outFormats
    add choser:
      else if(outputExt == "XXX") generator = new GeneratorXXX;


////////////////////////////////////////////////////////////////////////////////

3. CLASSES

A breakdown of the classes used in gnuclad.
Only the relevant public parts are shown, first the members and then the
constructors & methods.
We start with the simple classes, building up gradually.


A Color object can be initialised either with RGB (1-255)
or a hex color value (#abc or #abcdef).
It will automatically convert and hold the other value too.

class Color
  int red;
  int green;
  int blue;
  std::string hex;

  Color(int tred, int tgreen, int tblue);
  Color(std::string thex);


The Date object can be initialised either with year,month,day
or with a string in the format "y.m.d" or "y.m" or "y", where the letters
can be arbitary (also negative) integers.
The monthset/dayset switches tell the generator whether to honor the month and
day settings. They should be ignored by the parser.

class Date
  int year;
  int month;
  int day;

  bool monthset;
  bool dayset;

  Date(int tyear, int tmonth, int tday);
  Date(const std::string str);

  bool operator<(Date d);
  Date operator+(Date d);


The Image object is to be initialised only with addImage() in the parser:
  Image * Cladogram::addImage(std::string tname, std::vector<Image *> &vector);
The parser has to specify the vector it wants the image to be loaded, currently
only includeSVG.
It is usually passed to the generator unchanged and contains three members.

class Image
  std::string filename;
  int x;
  int y;


class Icon: TODO, MAY BE SUBJECT TO CHANGE


The NameChange is to be initialised only with addNameChange() in the parser:
  void Node::addNameChange(std::string newName, Date date,
                           std::string description);
The generator can access the nameChanges vector of the Node, making use of the
three members.

class NameChange
  std::string newName;
  Date date;
  std::string description;


The second most important class, a single Node.
It should be initialised only with the addNode() method:
  Node * Cladogram::addNode(std::string tname);
The 'offset' is meant for the generator (it can be ignored by the parser).

class Node
  std::string name
  std::string parentName
  std::vector<NameChange> nameChanges;
  Date start
  Date stop
  Color color
  Icon icon
  std::string description;
  int offset;

  void addNameChange(std::string newName, Date date, std::string description);


The Domain is to be initialised only with addDomain() in the parser:
  Domain * Cladogram::addDomain(std::string tname);
The 'offsetA' and 'offsetB' are meant for the generator (they can be ignored
by the parser).

class Domain
  std::string nodeName;
  Color color;
  int intensity;
  int offsetA;
  int offsetB;


The Connector is to be initialised only with addConnector() in the parser:
  Connector * Cladogram::addConnector();
The 'offsetA' and 'offsetB' are meant for the generator (they can be ignored
by the parser).

class Connector
  std::string fromName;
  std::string toName;
  Date fromWhen;
  Date toWhen;
  int thickness;
  Color color;
  int offsetA;
  int offsetB;


The most important class is the Cladogram. It is used by a single object which
describes the whole timeline and will be passed to the parser/generator.
The Cladogram usually doesn't need to be accessed by the parser, except for the
add*** functions.
The generator is meant to make use of the data vectors.

class Cladogram
  std::vector<Node *> nodes;
  std::vector<Connector *> connectors;
  std::vector<Domain *> domains;
  std::vector<Image *> includeSVG;

  Node * addNode(std::string tname);
  Domain * addDomain(std::string tname);
  Connector * addConnector();
  Image * addImage(std::string tname, std::vector<Image *> &vector);

The cladogram also holds all configuration options. These are usually read by
a separate configuration parser, but can be modified by your parser if necessary
and should implemented by the generator as completely as possible.

  Date endOfTime;

  std::string infoBoxTitle;
  std::vector<std::string> infoBoxText;
  int infoBoxTitleSize;
  std::string infoBoxFont;
  int infoBoxTextSize;
  Color infoBoxFontColor;
  Color infoBoxColor1;
  Color infoBoxColor2;
  int infoBoxX;
  int infoBoxY;
  int infoBoxWidth;
  int infoBoxHeight;

  double fontCorrectionFactor;
  int orientation;
  int treeMode;
  int sortKey;
  int optimise;
  int treeSpacing;
  int treeSpacingBiggerThan;

  Color mainBackground;
  int rulerWidth;
  Color rulerColor;
  int rulerMonthWidth;
  Color rulerMonthColor;

  int lineWidth;
  int offsetPX;
  int stopFadeOutPX;
  Date stopSpacing;
  int yearPX;

  std::string labelFont;
  int labelFontSize;
  Color labelFontColor;
  int labelBackground;
  int nameChangeType;

  int derivType;
  int dotRadius;
  int smallDotRadius;
  int dotType;

  int connectorDots;
  int connectorsDashed;

  int yearLinePX;
  Color yearLineColor1;
  Color yearLineColor2;
  std::string yearLineFont;
  int yearLineFontSize;
  Color yearLineFontColor;

  int monthsInYear;
  int daysInMonth;
  int descriptionIsHyperLink;

  int debug;


////////////////////////////////////////////////////////////////////////////////

4. HOW TO WRITE A PARSER:

Your parser is called only by this function:
  parser->parseData(Cladogram * clad, std::ifstream * fp);

Therefore it should implement the following one:
  void ParserXXX::parseData(Cladogram * clad, std::ifstream * fp) { ... }


The file pointer is a correctly opened file with the desired file name
extension, though you have to check whether the file structure/format is valid
yourself. The cladogram pointer is an empty Cladogram object that you have
to fill.
The parser essentially defines the input file format.
You should try to fill as much of the Cladogram as possible in order to increase
the information pool for the output generator. For a quick view of all the
variables, take a look at the description of the Cladogram in the 'Classes'
chapter. Note that not all generators will make use of every piece of data,
and it all depends on the options the user has set; the more information the
better.
If you cannot fill a field, leave it empty and the generators will ignore it.
All measures (height, thickness, ...) are "generic units".

Objects created with the add*** functions will be allocated and later deleted
automatically.
It is important to use those functions for objects you wish to pass on to the
generator.

Adding a Node:

  Node * n = clad->addNode("MyFirstNode");
  n->color = Color("#a2b3c4");
  n->parentName = "";
  n->start =  Date(1993,8,1);
  n->stop = Date("2000.3");
  n->icon = "";
  n->description = "it rocks!";
  n->addNameChange("NewName", Date("1999.2.1"), "it still rocks!")


Adding a Connector (note that fromName and toName are expected to be Node names
that will have been added at the end of the parser routine):

  Connector * c = clad->addConnector();
  c->fromWhen = Date(1997,0,0);
  c->fromName = "MyFirstNode";
  c->toWhen = Date("1997.5.1");
  c->toName = "MySecondNode";
  c->thickness = 3;
  c->color = Color(12,255,0);


Adding a domain (note that the initalising name is expected to be a Node name
that will have been added at the end of the parser routine):

  Domain * d = clad->addDomain("MyFirstNode");
  d->color = Color("#abc");
  d->intensity = 15;


Adding an image (currently only SVG is supported):

  Image * image = clad->addImage("picture.svg", clad->includeSVG);
  image->x = 100;
  image->y = 50;


////////////////////////////////////////////////////////////////////////////////

5. HOW TO WRITE A GENERATOR

Your generator is called only by this function:
  generator->writeData(Cladogram * clad, std::ofstream * fp);

Therefore it should implement the following one:
  void generatorXXX::writeData(Cladogram * clad, std::ofstream * fp) { ... }


The file pointer is a correctly opened file with the desired file name
extension.
You should try to use as much of the Cladogram information as possible.
This can be done by iterating over the Cadlogram's data vectors, currently:
vector<Node *> nodes
vector<Connector *> connectors
vector<Domain *> domains
vector<Image *> includeSVG

Additionally, you should strive to make use of all configuration options the
Cladogram contains. For an overview, take a look at the 'Classes' chapter.

If a variable is empty, try to handle it as gracefully as possible.
All measures (height, thickness, ...) are "generic units".

Example:

  Node * n;
  for(int i = 0; i < (int)clad->nodes.size(); ++i) {

    n = clad->nodes.at(i);
    cout << "\nWe have " << n->name
         << " at offset " << n->offset;

  }

  cout << "\n\nOur end of time is "
       << Date2str(clad->endOfTime) << "\n";


////////////////////////////////////////////////////////////////////////////////

6. UTILITY FUNCTIONS

Here's a list of small helpers you can get when including "gnuclad.h".
This is meant as a quick reference. For exact descriptions, take a look at
gnuclad-helpers.cpp

void pressEnter();

std::string strToLower(std::string str);

std::string getBaseName(std::string fname);

std::string getExt(std::string fname);

std::ifstream * new_infile(const std::string fname);

std::ofstream * new_outfile(const std::string fname);

void safeClose(std::ifstream * fp);

void safeClose(std::ofstream * fp);

void explode(const std::string str, const char delimiter,
             std::vector<std::string> * v);

void explodeSafely(const std::string str, const char delimiter,
                   const char toggle, std::vector<std::string> * v);

std::string findReplace(std::string str, std::string find, std::string replace);

double str2double(const std::string str);

int str2int(const std::string s);

std::string int2str(const int n);

Date currentDate();

std::string Date2str(Date date);

int datePX(Date d, const Cladogram * clad);
