<html lang="en">
<head>
<title>Programming - gnuclad manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="gnuclad manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="FAQ.html#FAQ" title="FAQ">
<link rel="next" href="GNU-Free-Documentation-License.html#GNU-Free-Documentation-License" title="GNU Free Documentation License">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This is a manual for gnuclad

Copyright (C) 2010 Donjan Rodic <donjan (at) dyx (dot) ch>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Programming"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="GNU-Free-Documentation-License.html#GNU-Free-Documentation-License">GNU Free Documentation License</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="FAQ.html#FAQ">FAQ</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<h2 class="chapter">5 Programming</h2>

<h3 class="section">5.1 Contributing</h3>

<p>Here's a small documentation if you wish to hack gnuclad. 
Patches are always welcome. New parsers/generators even more so!

<!-- _______________________________________________________ ADDING CONFIG OPTIONS -->
<h3 class="section">5.2 Adding configuration options</h3>

<p>When adding a configuration option, be sure to implement it at least in the
following places:
     <ul>
<li>gnuclad.h declaration (members of the Cladogram class)
<li>gnuclad.cpp initalisation (in the constructor of the Cladogram object)
<li>gnuclad.cpp parser (in the parseOptions function)
<li>generatorCONF.cpp
<li>the texinfo documentation, chapter Config Options (insert the new config
      file created by generatorCONF)
<li>third party gnuclad configuration files you have access to
</ul>

   <p>In order to work with the most current config options, open the 'gnuclad.h'
source file and search for CONFIG OPTIONS. This will take you straight to the
declarations.

<!-- _____________________________________________________ ADDING PARSER/GENERATOR -->
   <p><a name="index-Adding-a-parser_002fgenerator-4"></a>

<h3 class="section">5.3 Adding a parser/generator</h3>

<p>Parsers read data from various sources into the Cladogram object,
generators write data from the Cladogram object to a specified output format.

   <p>This is a short overview on the steps necessary to include a parser/generator. 
For detailed information, see the "How to write a ..." sections below.

   <p><strong>Adding a parser</strong>

   <p>parserXXX.h:
<pre class="example">     #include "gnuclad.h"
     derive class from Parser:
       class ParserXXX: public Parser
     declare constructor and destructor
     declare public method:
       void parseData(Cladogram * clado, std::ifstream * fp);
</pre>
   <p>parserXXX.cpp:
<pre class="example">     #include "parserXXX.h"
     implement constructor and destructor
     implement parseData(Cladogram * clad, std::ifstream * fp);
</pre>
   <p>gnuclad.cpp:
<pre class="example">     #include "parserXXX.h"
     update inFormats
     add choser:
       else if(inputExt == "XXX") parser = new ParserXXX;
</pre>
   <p><strong>Adding a generator</strong>

   <p>generatorXXX.h:
<pre class="example">     #include "gnuclad.h"
     derive class from generator:
       class GeneratorXXX: public Generator
     declare constructor and destructor
     declare public method:
       void writeData(Cladogram * clad, std::ofstream * fp);
</pre>
   <p>generatorXXX.cpp:
<pre class="example">     #include "generatorXXX.h"
     implement constructor and destructor
     implement writeData();
</pre>
   <p>gnuclad.cpp
<pre class="example">     #include "generatorXXX.h"
     update outFormats
     add choser:
       else if(outputExt == "XXX") generator = new GeneratorXXX;
</pre>
   <!-- _____________________________________________________________________ CLASSES -->
   <p><a name="index-Classes-5"></a>

<h3 class="section">5.4 Classes</h3>

<p>A breakdown of the classes used in gnuclad. 
Only the relevant public parts are shown, first the members and then the
constructors &amp; methods. 
We start with the simple classes, building up gradually.

   <p><br>
A Color object can be initialised either with RGB (1-255)
or a hex color value (#abc or #abcdef). 
It will automatically convert and hold the other value too.
<pre class="example">     class Color
       int red;
       int green;
       int blue;
       std::string hex;
     
       Color(int tred, int tgreen, int tblue);
       Color(std::string thex);
</pre>
   <p><br>
The Date object can be initialised either with year,month,day
or with a string in the format "y.m.d" or "y.m" or "y", where the letters
can be arbitrary (also negative) integers. 
The monthset/dayset switches tell the generator whether to honor the month and
day settings. They should be ignored by the parser.
<pre class="example">     class Date
       int year;
       int month;
       int day;
     
       bool monthset;
       bool dayset;
     
       Date(int tyear, int tmonth, int tday);
       Date(const std::string str);
     
       bool operator&lt;(Date d);
       Date operator+(Date d);
</pre>
   <p><br>
The Image object is to be initialised only with addImage() in the parser:
<pre class="example">       Image * Cladogram::addImage(std::string tname, std::vector&lt;Image *&gt; &amp;vector);
</pre>
   <p>The parser has to specify the vector it wants the image to be loaded into (see
the Cladogram class below for details). 
It is usually passed to the generator unchanged and contains three members.
<pre class="example">     class Image
       std::string filename;
       int x;
       int y;
</pre>
   <p><br>
The NameChange is to be initialised only with addNameChange() in the parser:
<pre class="example">       void Node::addNameChange(std::string newName, Date date,
                                std::string description);
</pre>
   <p>The generator can access the nameChanges vector of the Node, making use of the
three members.
<pre class="example">     class NameChange
       std::string newName;
       Date date;
       std::string description;
</pre>
   <p><br>
The second most important class, a single Node. 
It should be initialised only with the addNode() method:
<pre class="example">       Node * Cladogram::addNode(std::string tname);
</pre>
   <p>The 'offset' is meant for the generator (it can be ignored by the parser).
<pre class="example">     class Node
       std::string name
       std::string parentName
       std::vector&lt;NameChange&gt; nameChanges;
       Date start;
       Date stop;
       Color color;
       std::string iconfile;
       std::string description;
       int offset;
     
       void addNameChange(std::string newName, Date date, std::string description);
</pre>
   <p><br>
The Domain is to be initialised only with addDomain() in the parser:
<pre class="example">       Domain * Cladogram::addDomain(std::string tname);
</pre>
   <p>The 'offsetA' and 'offsetB' are meant for the generator (they can be ignored
by the parser).
<pre class="example">     class Domain
       std::string nodeName;
       Color color;
       int intensity;
       int offsetA;
       int offsetB;
</pre>
   <p><br>
The Connector is to be initialised only with addConnector() in the parser:
<pre class="example">       Connector * Cladogram::addConnector();
</pre>
   <p>The 'offsetA' and 'offsetB' are meant for the generator (they can be ignored
by the parser).
<pre class="example">     class Connector
       std::string fromName;
       std::string toName;
       Date fromWhen;
       Date toWhen;
       int thickness;
       Color color;
       int offsetA;
       int offsetB;
</pre>
   <p><br>
The most important class is the Cladogram. It is used by a single object which
describes the whole timeline and will be passed to the parser/generator. 
The Cladogram usually doesn't need to be accessed by the parser, except for the
add*** functions. 
The generator is meant to make use of the data vectors.
<pre class="example">     class Cladogram
       std::vector&lt;Node *&gt; nodes;
       std::vector&lt;Connector *&gt; connectors;
       std::vector&lt;Domain *&gt; domains;
       std::vector&lt;Image *&gt; includeSVG;
       std::vector&lt;Image *&gt; includePNG;
     
       Node * addNode(std::string tname);
       Domain * addDomain(std::string tname);
       Connector * addConnector();
       Image * addImage(std::string tname, std::vector&lt;Image *&gt; &amp;vector);
</pre>
   <p>The cladogram also holds all configuration options. These are usually read by
a separate configuration parser, but can be modified by your parser if necessary
and should implemented by the generator as completely as possible. 
The option names are identical to the variable names.

   <p>In order to work with the most current config options, open the 'gnuclad.h'
header file and search for CONFIG OPTIONS. This will take you straight to the
declarations.

   <p>You can also look at the 'Config Options' manual chapter for an overview.

<!-- _______________________________________________________________ HOW TO PARSER -->
<h3 class="section">5.5 How to write a parser</h3>

<p>Your parser is called only by this function:
<pre class="example">       parser-&gt;parseData(Cladogram * clad, std::ifstream * fp);
</pre>
   <p>Therefore it should implement the following one:
<pre class="example">       void ParserXXX::parseData(Cladogram * clad, std::ifstream * fp) { ... }
</pre>
   <p>The file pointer is a correctly opened file with the desired file name
extension, though you have to check whether the file structure/format is valid
yourself. The cladogram pointer is an empty Cladogram object that you have
to fill. 
<br><em>The parser essentially defines the input file format.</em><br>
You should try to fill as much of the Cladogram as possible in order to increase
the information pool for the output generator. For a quick view overview, take a
look at the description of the Cladogram in the 'Classes' section. Note that
not all generators will make use of every piece of data, and it all depends on
the options the user has set; the more information the better.

   <p>If you cannot fill a field, leave it empty and the generators will ignore it. 
All measures (height, thickness, ...) are "generic units".

   <p>Objects created with the add*** functions will be allocated and later deleted
automatically. 
It is important to use those functions for objects you wish to pass on to the
generator.

   <p><br>
Adding a Node:
<pre class="example">       Node * n = clad-&gt;addNode("MyFirstNode");
       n-&gt;color = Color("#a2b3c4");
       n-&gt;parentName = "";
       n-&gt;start =  Date(1993,8,1);
       n-&gt;stop = Date("2000.3");
       n-&gt;iconfile = "";
       n-&gt;description = "it rocks!";
       n-&gt;addNameChange("NewName", Date("1999.2.1"), "it still rocks!")
</pre>
   <p><br>
Adding a Connector (note that fromName and toName are expected to be existing
Node names at the end of the parser routine - you'll get an error otherwise):
<pre class="example">       Connector * c = clad-&gt;addConnector();
       c-&gt;fromWhen = Date(1997,0,0);
       c-&gt;fromName = "MyFirstNode";
       c-&gt;toWhen = Date("1997.5.1");
       c-&gt;toName = "MySecondNode";
       c-&gt;thickness = 3;
       c-&gt;color = Color(12,255,0);
</pre>
   <p><br>
Adding a domain (note that the initialising name is expected to be an existing
Node name at the end of the parser routine - you'll get an error otherwise):
<pre class="example">       Domain * d = clad-&gt;addDomain("MyFirstNode");
       d-&gt;color = Color("#abc");
       d-&gt;intensity = 15;
</pre>
   <p><br>
Adding an image (currently supported: SVG and PNG):
<pre class="example">       Image * image = clad-&gt;addImage("picture.svg", clad-&gt;includeSVG);
       image-&gt;x = 100;
       image-&gt;y = 50;
     
       Image * image = clad-&gt;addImage("picture.svg", clad-&gt;includePNG);
       image-&gt;x = 10;
       image-&gt;y = 500;
</pre>
   <!-- ____________________________________________________________ HOW TO GENERATOR -->
<h3 class="section">5.6 How to write a generator</h3>

<p>Your generator is called only by this function:
<pre class="example">       generator-&gt;writeData(Cladogram * clad, std::ofstream * fp);
</pre>
   <p>Therefore it should implement the following one:
<pre class="example">       void generatorXXX::writeData(Cladogram * clad, std::ofstream * fp) { ... }
</pre>
   <p>The file pointer is a correctly opened file with the desired file name
extension.<br>
You should try to utilise as much information as possible. 
This can be done by iterating over the Cadlogram's data vectors:
<pre class="example">     vector&lt;Node *&gt; nodes
     vector&lt;Connector *&gt; connectors
     vector&lt;Domain *&gt; domains
     vector&lt;Image *&gt; includeSVG
     vector&lt;Image *&gt; includePNG
</pre>
   <p>Additionally, you should strive to make use of all configuration options the
Cladogram contains. 
In order to work with the most current config options, open the 'gnuclad.h'
header file and search for CONFIG OPTIONS. This will take you straight to the
declarations.

   <p>If a variable is empty, try to handle it as gracefully as possible. 
All measures (height, thickness, ...) are "generic units".

   <p>Example:
<pre class="example">       Node * n;
       for(int i = 0; i &lt; (int)clad-&gt;nodes.size(); ++i) {
     
         n = clad-&gt;nodes.at(i);
         cout &lt;&lt; "\nWe have " &lt;&lt; n-&gt;name
              &lt;&lt; " at offset " &lt;&lt; n-&gt;offset;
     
       }
     
       cout &lt;&lt; "\n\nOur end of time is "
            &lt;&lt; Date2str(clad-&gt;endOfTime) &lt;&lt; "\n";
     
       cout &lt;&lt; "\n\nOur background color (in hex) is "
            &lt;&lt; mainBackground.hex &lt;&lt; "\n";
</pre>
   <!-- ___________________________________________________________ UTILITY FUNCTIONS -->
   <p><a name="index-Utility-functions-6"></a>

<h3 class="section">5.7 Utility functions</h3>

<p>Here's a list of small helpers you can get when including 'gnuclad.h'. 
This is meant as a quick overview. For descriptions, take a look at
the 'gnuclad-helpers.cpp' source file.

   <p>void pressEnter();

   <p>std::string strToLower(std::string str);

   <p>std::string getBaseName(std::string fname);

   <p>std::string getExt(std::string fname);

   <p>std::ifstream * new_infile(const std::string fname);

   <p>std::ofstream * new_outfile(const std::string fname);

   <p>void safeClose(std::ifstream * fp);

   <p>void safeClose(std::ofstream * fp);

   <p>void explode(const std::string str, const char delimiter,
             std::vector&lt;std::string&gt; * v);

   <p>void explodeSafely(const std::string str, const char delimiter,
                   const char toggle, std::vector&lt;std::string&gt; * v);

   <p>std::string findReplace(std::string str, std::string find, std::string replace);

   <p>double str2double(const std::string str);

   <p>int str2int(const std::string s);

   <p>std::string int2str(const int n);

   <p>std::string base64_encode(const char * raw, unsigned int len);

   <p>Date currentDate();

   <p>std::string Date2str(Date date);

   <p>int datePX(Date d, const Cladogram * clad);

<!-- ________________________________________________________________________ GFDL -->
   </body></html>

