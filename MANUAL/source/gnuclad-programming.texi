@c Part of the gnuclad texinfo manual


@node Programming
@chapter Programming

@section Contributing

Here's a small documentation if you wish to hack gnuclad.
Patches are always welcome. New parsers/generators even more so!

@c _______________________________________________________ ADDING CONFIG OPTIONS

@section Adding configuration options

When adding a configuration option, be sure to implement it at least in the
following places:
@itemize @bullet
@item gnuclad.h declaration
@item gnuclad.cpp initalisation (in the constructor of the Cladogram object)
@item gnuclad.cpp parser (in the parseOptions function)
@item generatorCONF.cpp
@item the texinfo documentation, chapter Config Options (insert the config file
      created by generatorCONF)
@item third party gnuclad configuration files you have access to
@end itemize

In order to work with the most current config options, open the 'gnuclad.h'
source file and search for CONFIG OPTIONS. This will take you straight to the
declarations.

@c _____________________________________________________ ADDING PARSER/GENERATOR

@cindex Adding a parser/generator
@section Adding a parser/generator

Parsers read data from various sources into the Cladogram object,
generators write data from the Cladogram object to a specified output format.

This is a short overview on the steps necessary to include a parser/generator.
For detailed information, see the "How to write a ..." sections below.

@strong{Adding a parser}

parserXXX.h:
@example
#include "gnuclad.h"
derive class from Parser:
  class ParserXXX: public Parser
add public method:
  void parseData(Cladogram * clado, std::ifstream * fp);
@end example

parserXXX.cpp:
@example
#include "parserXXX.h"
implement parseData(Cladogram * clad, std::ifstream * fp);
@end example

gnuclad.cpp:
@example
#include "parserXXX.h"
update inFormats
add choser:
  else if(inputExt == "XXX") parser = new ParserXXX;
@end example

@strong{Adding a generator}

generatorXXX.h:
@example
#include "gnuclad.h"
derive class from generator:
  class GeneratorXXX: public Generator
add public method:
  void writeData(Cladogram * clad, std::ofstream * fp);
@end example

generatorXXX.cpp:
@example
#include "generatorXXX.h"
implement writeData();
@end example

gnuclad.cpp
@example
#include "generatorXXX.h"
update outFormats
add choser:
  else if(outputExt == "XXX") generator = new GeneratorXXX;
@end example


@c _____________________________________________________________________ CLASSES


@cindex Classes
@section Classes


A breakdown of the classes used in gnuclad.
Only the relevant public parts are shown, first the members and then the
constructors & methods.
We start with the simple classes, building up gradually.


@*
A Color object can be initialised either with RGB (1-255)
or a hex color value (#abc or #abcdef).
It will automatically convert and hold the other value too.
@example
class Color
  int red;
  int green;
  int blue;
  std::string hex;

  Color(int tred, int tgreen, int tblue);
  Color(std::string thex);
@end example


@*
The Date object can be initialised either with year,month,day
or with a string in the format "y.m.d" or "y.m" or "y", where the letters
can be arbitrary (also negative) integers.
The monthset/dayset switches tell the generator whether to honor the month and
day settings. They should be ignored by the parser.
@example
class Date
  int year;
  int month;
  int day;

  bool monthset;
  bool dayset;

  Date(int tyear, int tmonth, int tday);
  Date(const std::string str);

  bool operator<(Date d);
  Date operator+(Date d);
@end example


@*
The Image object is to be initialised only with addImage() in the parser:
@example
  Image * Cladogram::addImage(std::string tname, std::vector<Image *> &vector);
@end example
The parser has to specify the vector it wants the image to be loaded into (see
the Cladogram class below for details).
It is usually passed to the generator unchanged and contains three members.
@example
class Image
  std::string filename;
  int x;
  int y;
@end example


@*
The NameChange is to be initialised only with addNameChange() in the parser:
@example
  void Node::addNameChange(std::string newName, Date date,
                           std::string description);
@end example
The generator can access the nameChanges vector of the Node, making use of the
three members.
@example
class NameChange
  std::string newName;
  Date date;
  std::string description;
@end example


@*
The second most important class, a single Node.
It should be initialised only with the addNode() method:
@example
  Node * Cladogram::addNode(std::string tname);
@end example
The 'offset' is meant for the generator (it can be ignored by the parser).
@example
class Node
  std::string name
  std::string parentName
  std::vector<NameChange> nameChanges;
  Date start;
  Date stop;
  Color color;
  std::string iconfile;
  std::string description;
  int offset;

  void addNameChange(std::string newName, Date date, std::string description);
@end example


@*
The Domain is to be initialised only with addDomain() in the parser:
@example
  Domain * Cladogram::addDomain(std::string tname);
@end example
The 'offsetA' and 'offsetB' are meant for the generator (they can be ignored
by the parser).
@example
class Domain
  std::string nodeName;
  Color color;
  int intensity;
  int offsetA;
  int offsetB;
@end example


@*
The Connector is to be initialised only with addConnector() in the parser:
@example
  Connector * Cladogram::addConnector();
@end example
The 'offsetA' and 'offsetB' are meant for the generator (they can be ignored
by the parser).
@example
class Connector
  std::string fromName;
  std::string toName;
  Date fromWhen;
  Date toWhen;
  int thickness;
  Color color;
  int offsetA;
  int offsetB;
@end example


@*
The most important class is the Cladogram. It is used by a single object which
describes the whole timeline and will be passed to the parser/generator.
The Cladogram usually doesn't need to be accessed by the parser, except for the
add*** functions.
The generator is meant to make use of the data vectors.
@example
class Cladogram
  std::vector<Node *> nodes;
  std::vector<Connector *> connectors;
  std::vector<Domain *> domains;
  std::vector<Image *> includeSVG;
  std::vector<Image *> includePNG;

  Node * addNode(std::string tname);
  Domain * addDomain(std::string tname);
  Connector * addConnector();
  Image * addImage(std::string tname, std::vector<Image *> &vector);
@end example

The cladogram also holds all configuration options. These are usually read by
a separate configuration parser, but can be modified by your parser if necessary
and should implemented by the generator as completely as possible.
The option names are identical to the variable names.

In order to work with the most current config options, open the 'gnuclad.h'
header file and search for CONFIG OPTIONS. This will take you straight to the
declarations.

You can also look at the 'Config Options' manual chapter for an overview.



@c _______________________________________________________________ HOW TO PARSER



@section How to write a parser


Your parser is called only by this function:
@example
  parser->parseData(Cladogram * clad, std::ifstream * fp);
@end example

Therefore it should implement the following one:
@example
  void ParserXXX::parseData(Cladogram * clad, std::ifstream * fp) @{ ... @}
@end example

The file pointer is a correctly opened file with the desired file name
extension, though you have to check whether the file structure/format is valid
yourself. The cladogram pointer is an empty Cladogram object that you have
to fill.
@*@emph{The parser essentially defines the input file format.}@*
You should try to fill as much of the Cladogram as possible in order to increase
the information pool for the output generator. For a quick view overview, take a
look at the description of the Cladogram in the 'Classes' section. Note that
not all generators will make use of every piece of data, and it all depends on
the options the user has set; the more information the better.

If you cannot fill a field, leave it empty and the generators will ignore it.
All measures (height, thickness, ...) are "generic units".

Objects created with the add*** functions will be allocated and later deleted
automatically.
It is important to use those functions for objects you wish to pass on to the
generator.

@*
Adding a Node:
@example
  Node * n = clad->addNode("MyFirstNode");
  n->color = Color("#a2b3c4");
  n->parentName = "";
  n->start =  Date(1993,8,1);
  n->stop = Date("2000.3");
  n->iconfile = "";
  n->description = "it rocks!";
  n->addNameChange("NewName", Date("1999.2.1"), "it still rocks!")
@end example

@*
Adding a Connector (note that fromName and toName are expected to be existing
Node names at the end of the parser routine - you'll get an error otherwise):
@example
  Connector * c = clad->addConnector();
  c->fromWhen = Date(1997,0,0);
  c->fromName = "MyFirstNode";
  c->toWhen = Date("1997.5.1");
  c->toName = "MySecondNode";
  c->thickness = 3;
  c->color = Color(12,255,0);
@end example

@*
Adding a domain (note that the initialising name is expected to be an existing
Node name at the end of the parser routine - you'll get an error otherwise):
@example
  Domain * d = clad->addDomain("MyFirstNode");
  d->color = Color("#abc");
  d->intensity = 15;
@end example

@*
Adding an image (currently supported: SVG and PNG):
@example
  Image * image = clad->addImage("picture.svg", clad->includeSVG);
  image->x = 100;
  image->y = 50;

  Image * image = clad->addImage("picture.svg", clad->includePNG);
  image->x = 10;
  image->y = 500;
@end example


@c ____________________________________________________________ HOW TO GENERATOR


@section How to write a generator


Your generator is called only by this function:
@example
  generator->writeData(Cladogram * clad, std::ofstream * fp);
@end example

Therefore it should implement the following one:
@example
  void generatorXXX::writeData(Cladogram * clad, std::ofstream * fp) @{ ... @}
@end example

The file pointer is a correctly opened file with the desired file name
extension.@*
You should try to utilise as much information as possible.
This can be done by iterating over the Cadlogram's data vectors:
@example
vector<Node *> nodes
vector<Connector *> connectors
vector<Domain *> domains
vector<Image *> includeSVG
vector<Image *> includePNG
@end example

Additionally, you should strive to make use of all configuration options the
Cladogram contains.
In order to work with the most current config options, open the 'gnuclad.h'
header file and search for CONFIG OPTIONS. This will take you straight to the
declarations.

If a variable is empty, try to handle it as gracefully as possible.
All measures (height, thickness, ...) are "generic units".

Example:
@example
  Node * n;
  for(int i = 0; i < (int)clad->nodes.size(); ++i) @{

    n = clad->nodes.at(i);
    cout << "\nWe have " << n->name
         << " at offset " << n->offset;

  @}

  cout << "\n\nOur end of time is "
       << Date2str(clad->endOfTime) << "\n";

  cout << "\n\nOur background color (in hex) is "
       << mainBackground.hex << "\n";
@end example


@c ___________________________________________________________ UTILITY FUNCTIONS


@cindex Utility functions
@section Utility functions


Here's a list of small helpers you can get when including 'gnuclad.h'.
This is meant as a quick overview. For descriptions, take a look at
the 'gnuclad-helpers.cpp' source file.

void pressEnter();

std::string strToLower(std::string str);

std::string getBaseName(std::string fname);

std::string getExt(std::string fname);

std::ifstream * new_infile(const std::string fname);

std::ofstream * new_outfile(const std::string fname);

void safeClose(std::ifstream * fp);

void safeClose(std::ofstream * fp);

void explode(const std::string str, const char delimiter,
             std::vector<std::string> * v);

void explodeSafely(const std::string str, const char delimiter,
                   const char toggle, std::vector<std::string> * v);

std::string findReplace(std::string str, std::string find, std::string replace);

double str2double(const std::string str);

int str2int(const std::string s);

std::string int2str(const int n);

std::string base64_encode(const char * raw, unsigned int len);

Date currentDate();

std::string Date2str(Date date);

int datePX(Date d, const Cladogram * clad);
